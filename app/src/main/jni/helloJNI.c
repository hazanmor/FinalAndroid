/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_demonized_ndktest_WelcomeActivity.h"
#include <jni.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <openssl/ssl.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/bn.h>
#include <openssl/x509.h>
#include <openssl/x509_vfy.h>
#include <math.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>


int OpenConnection(const char *hostname, int port);
void ShowCerts(SSL* ssl);
SSL_CTX* InitCTX(void);

#define BN_size_in_bytes 16
#define BN_size_in_bits 128

void generateConstantPrivateKey(BIGNUM *h, BIGNUM *p, BIGNUM *g, BIGNUM *x);
void levelOneSend(int bit);
void levelTwoSend(int bit);
int count=0 ;
int Round=0;
BN_CTX *bn_ctx=0;
BIGNUM *q=0,*min=0,*max=0,*p=0, *g=0, *c=0, *a=0, *h=0;
int sockA,sockB, i,j;
SSL_CTX *ssl_ctx=0;
SSL *sslA=0, *sslB=0;
BIO *bio=0;
unsigned char buffer[BN_size_in_bytes]={0},buffer2[BN_size_in_bytes]={0}, temp='c';
int keyLength=0;


JNIEXPORT jstring JNICALL Java_com_demonized_ndktest_WelcomeActivity_helloJNI(JNIEnv *env, jobject obj){


int bytes=0;

	bn_ctx=BN_CTX_new();								//////////////////////
	p=BN_new();											//					//
	g=BN_new();											//	Initializes		//
	c=BN_new();											//	BIGNUM variables//
	a=BN_new();											//					//
	h=BN_new();											//////////////////////
	q=BN_new();

		min=BN_new();
	max=BN_new();
	bio= BIO_new_fp(stdout, BIO_NOCLOSE);				//Initializes output stream for BIGNUM variables
	if(p==0 || g==0 || c==0 || a==0 || h==0 || bio==0 || bn_ctx==0){
		printf("Couldn't initialize BIGNUM variables properly : Now exiting\n");
		exit(1);
	}

	SSL_library_init();									//Initializes SSL library
	ssl_ctx=InitCTX();									//Initializes SSL context
	sockA= OpenConnection("127.0.0.1",atoi("50000"));	//Opens socket to ServerA
	sslA=SSL_new(ssl_ctx);								//Initalizes SSL socket
	sslB=SSL_new(ssl_ctx);								//Initializes SSL socket
	if(sslA == 0 || sslB == 0){
		printf("Couldn't initialize SSL variables properly : Now exiting\n");
		exit(1);
	}
	if(SSL_set_fd(sslA,sockA)<=0)						//Binds regular&SSL socket
		printf("SSL A bind error\n");
	if(SSL_connect(sslA)==-1){							//Connects through SSL to ServerA
		printf("SSL A connect failed\n");
		exit(1);
	}
	printf("SSL A connected with %s encryption\n", SSL_get_cipher(sslA));
	ShowCerts(sslA);									//Prints certificates for ServerA
	sockB= OpenConnection("127.0.0.1",atoi("50002"));	//Opens socket to ServerB

	if(SSL_set_fd(sslB,sockB)<=0)						//Binds regular&SSL socket
		printf("SSL B bind error\n");
	if(SSL_connect(sslB)==-1){							//Connects through SSL to ServerB
		printf("SSL B connect failed\n");
		exit(1);
	}
	printf("SSL B connected with %s encryption\n", SSL_get_cipher(sslB));
	ShowCerts(sslB);									//Prints certificates for ServerB
	generateConstantPrivateKey(h,p,g,c);				//Generates the constant keys for encryption
	printf("Successfuly generated the prime number, generator and private key\n p=\n");
	BN_bn2bin(g,buffer);
	SSL_write(sslA,buffer,BN_num_bytes(g));
	SSL_write(sslB,buffer,BN_num_bytes(g));
	BN_bn2bin(p,buffer);
	SSL_write(sslA,buffer,BN_num_bytes(p));
	SSL_write(sslB,buffer,BN_num_bytes(p));

levelTwoSend(1);								//// send K

char  password[] ="Daniel";
char try[] = "Daniel";
int k = 0;

for(k=0;k< 6;k++){
for(j=0;j<8;j++){

		i=(*(password+k)>>j)&1;
		levelOneSend(i);							//Level one computation and transmission
		levelTwoSend(i);							//Level two computation and transmission
		printf("%d",i);
	}
}
	printf("\n");
	for(k=0;k<6;k++){

	for(j=0;j<8;j++){
			i=(*(try+k)>>j)&1;
			levelOneSend(i);							//Level one computation and transmission
			levelTwoSend(i);							//Level two computation and transmission
			printf("%d",i);
		}
	}
	printf("\n");
	BN_free(h);											//////////////////////////////
	BN_free(g);											//	BIGNUM Variables		//
	BN_free(a);											//							//
	BN_free(c);											//	Deletion and cleanup	//
	BN_free(p);											//							//
	BN_free(q);
	BN_free(min);
	BN_free(max);
	BN_CTX_free(bn_ctx);								//////////////////////////////


	close(sockA);										///////////////////////////////
	close(sockB);										//	Closes sockets			 //
	SSL_free(sslA);										//							 //
	SSL_free(sslB);										//	and cleans SSL variables //
	SSL_CTX_free(ssl_ctx);								///////////////////////////////

	return (*env)->NewStringUTF(env,"Hello from jni");

}

void generateConstantPrivateKey(BIGNUM *h, BIGNUM *p, BIGNUM *g, BIGNUM *x){
	int flag=1;
	BIGNUM  *temp=0;
	temp=BN_new();

	if(q==0 || temp==0)
		exit(1);
	if(BN_generate_prime_ex(p,BN_size_in_bits,1,NULL,NULL,NULL)<1){
		printf("Error occurred :) \n");
		exit(1);
	}
//
//	if(!BN_generate_prime(p,BN_size_in_bits,1,0,0,0,0)){
//		printf("Error occurred :) \n");
//		exit(1);
//	}


	BN_sub(temp,p,BN_value_one());
	if ( ! BN_rshift1(q,p) ) 					// q = (p-1)/2
		exit(1);

do{
	if(!BN_rand_range(x,q))							//randomizes the constant private key
		exit(1);

}while(BN_num_bytes(x)!=BN_size_in_bytes);
////////////////////// generate generator g //////////////////////
	do{
		flag=0;

			if(!BN_rand_range(g,q))					///// randomize g
				exit(1);

		if (0>=BN_cmp(g,BN_value_one()))			//Asserts g>1
			flag=1;
		else{
			if(!BN_mod_sqr(temp,g, p,bn_ctx))		//temp = sqrt(g)
				exit(1);
			if(0==BN_cmp(temp,BN_value_one()))		//Asserts temp!=1
				flag=1;
			if(!BN_mod_exp(temp,g,q,p,bn_ctx))		//temp = (g^q)mod(p)
				exit(1);
			if(0==BN_cmp(temp,BN_value_one()))		//Asserts ((g^q)mod(p))! = 1
				flag=1;
		}
	}while(flag);

	/* If we got here, we found a generator of the Z*p group */

	BN_mod_mul(g,g,g,p,bn_ctx);						// g=g^2

	if(!BN_mod_exp(h,g,x,p,bn_ctx))					//sets h as the public key
		exit(1);

	BN_free(temp);

	keyLength= BN_num_bits(x);

}

void levelOneSend(int bit){
	BIGNUM  *hTemp=0;
	int i;
	hTemp=BN_new();
	if(hTemp==0)
		exit(1);

	if(!BN_rand_range(a,q))
		exit(1);

BN_mod_exp(hTemp,g,a,p,bn_ctx);				//create g^a
	BN_bn2bin(hTemp,buffer);
	SSL_write(sslA,buffer,BN_num_bytes(hTemp));
	SSL_write(sslB,buffer,BN_num_bytes(hTemp));
	BN_mod_exp(hTemp,h,a,p,bn_ctx);			//create g^(a*c)
	if(bit)
	BN_mod_mul(hTemp,hTemp,g,p,bn_ctx);		//create g^((a*c)+m)
	memset(buffer,'\0',BN_size_in_bytes);
	BN_bn2bin(hTemp,buffer);
	 SSL_write(sslA,buffer,BN_num_bytes(hTemp));
	SSL_write(sslB,buffer,BN_num_bytes(hTemp));

	for (i=0;i<BN_size_in_bits;i++){

			if(!BN_rand_range(a,q))
				exit(1);

		BN_mod_exp(hTemp,g,a,p,bn_ctx);			//create g^a
		BN_bn2bin(hTemp,buffer);
		SSL_write(sslA,buffer,BN_num_bytes(hTemp));
		SSL_write(sslB,buffer,BN_num_bytes(hTemp));
		BN_mod_exp(hTemp,h,a,p,bn_ctx);		//create g^(a*c)
		if(bit && BN_is_bit_set(c,i)&& i< keyLength)
			BN_mod_mul(hTemp,hTemp,g,p,bn_ctx);	//if bit Ci of key is set, multiply by generator

		BN_bn2bin(hTemp,buffer);
		SSL_write(sslA,buffer,BN_num_bytes(hTemp));
		SSL_write(sslB,buffer,BN_num_bytes(hTemp));
		}
	BN_free(hTemp);
}

void levelTwoSend(int bit){

	BIGNUM *share0=0, *share1=0, *shareC0=0, *shareC1;
	share0=BN_new();
	share1=BN_new();
	shareC0=BN_new();
	shareC1=BN_new();


			if(!BN_rand_range(share0,q))
				exit(1);

		BN_copy(shareC0,share0);


	if(share0==0 || share1==0 || shareC0==0|| shareC1==0)
		exit(1);
	if(bit){
		if(!BN_mod_sub(share1,share0,BN_value_one(),q,bn_ctx))
			exit(1);
		if(!BN_mod_sub(shareC1,share0,c,q,bn_ctx))
			exit(1);
	}else	{	BN_copy(share1,share0);
					BN_copy(shareC1,shareC0);
				}
//////////////////////////////////////////////////

		BN_bn2bin(share0,buffer);
		SSL_write(sslA,buffer,BN_num_bytes(share0));
		BN_bn2bin(share1,buffer);
		SSL_write(sslB,buffer,BN_num_bytes(share1));
		BN_bn2bin(shareC0,buffer);
		SSL_write(sslA,buffer,BN_num_bytes(shareC0));
		BN_bn2bin(shareC1,buffer);
		SSL_write(sslB,buffer,BN_num_bytes(shareC1));


	BN_free(share0);
	BN_free(share1);
	BN_free(shareC0);
	BN_free(shareC1);
}

//////////////////////////////////////////////////////
/*Below are all the functions responsible for		*/
/*regular & SSL secured connections initializations */
//////////////////////////////////////////////////////

int OpenConnection(const char *hostname, int port){
	int sd;
	struct hostent *host;
	struct sockaddr_in addr;

	if ( (host = gethostbyname(hostname)) == NULL ){
		perror(hostname);
		abort();
	}
	sd = socket(AF_INET, SOCK_STREAM, 0);
	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = *(long*)(host->h_addr);
	if ( connect(sd, (struct sockaddr*)&addr, sizeof(addr)) != 0 ){
		close(sd);
		perror(hostname);
		abort();
	}
	return sd;
}
SSL_CTX* InitCTX(void){
	SSL_METHOD *method;
	SSL_CTX *ctx;

	OpenSSL_add_all_algorithms();  /* Load cryptos, et.al. */
	SSL_load_error_strings();   /* Bring in and register error messages */
	method = SSLv23_client_method();  /* Create new client-method instance */
	ctx = SSL_CTX_new(method);   /* Create new context */
	if ( ctx == NULL ){
		ERR_print_errors_fp(stderr);
		abort();
	}
	return ctx;
}
void ShowCerts(SSL* ssl){
	X509 *cert;
	char *line;

	cert = SSL_get_peer_certificate(ssl); /* get the server's certificate */
	if ( cert != NULL ){
		printf("Server certificates:\n");
		line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
		printf("Subject: %s\n", line);
		free(line);       /* free the malloc'ed string */
		line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
		printf("Issuer: %s\n", line);
		free(line);       /* free the malloc'ed string */
		X509_free(cert);     /* free the malloc'ed certificate copy */
	}else
		printf("Info: No client certificates configured.\n");
}
